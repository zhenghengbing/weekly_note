# 一致性协议---2PC与3PC
## 分布式架构
  一致性协议的出现是为了解决分布式架构中的分布式事务问题，所以在了解一致性协议2PC和3PC之前，应该先简单的了解一下分布式架构。  
  分布式架构出现之前，采用的是一种集中式的系统架构，也就是所有的数据和业务单与都存放在一台或者多台计算机中，这些计算机组成一个中心节点。在集中式系统中，每个终端或客户端仅仅负责数据的录入与输出，而数据的存储和处理都由这个中心节点来处理。  
### 分布式的特点
1.分布性：分布式系统中的多台计算机在空间上随意分布，机器的分布情况也会随时变动。  
2.对等性：分布式系统中的计算机没有主从之分，既没有控制整个系统的主机，也没有被控制的丛机，所有计算机都是对等的。另外在分布式系统中，多个计算机节点可能会对数据和服务进行冗余的存储，以达到每个节点都有能力接受并处理来自外部的请求。  
3.并发性：并发性指的是多个节点的计算机可能对一些共享的资源同时进行操作，诸如对数据的存储和更新等。  
4.缺乏全局时钟：一个典型的分布式系统是由一系列在空间上随机分布的多个进程组成，进程之间通过交换消息来进行通信。很难定义两个时间谁先谁后，原因就是分布式系统缺乏一个全局的时钟列控制。  
### 分布式环境存在的一些问题
1.**通信异常**：分布式系统架构中各个节点之间的通信必然需要通过网络，由于网络的不稳定性，就给分布式带来了一些额外的问题。  
2.**网络分区**：由于出现了网络异常，可能会导致分布式系统中只有一部分节点可以正常通信，另一些节点就不能。这些局部小集群需要处理原来整个分布式系统才能完成的功能，包括对数据的事务处理，这就对分布式一致性提出了挑战。  
3.**三态**：在传统的单机系统中，应用程序调用一个函数之后，能都得到一个非常明确地答复，成功或者失败，但是在分布式架构中，由于引入了网络因素，由于网络的因素，因此分布式系统的每一次请求和响应存在特有的三态概念，即成功，失败和超时。当出现网络超时的时候，通信发起方无法确定当前请求是否被成功处理。  
4.**节点故障**：节点故障是分布式系统中比较常见的问题，就是指分布式中的某一个服务节点出现宕机和僵死现象。  
## 分布式事务
  事务是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。  
  事务具有四个特征，分别是原子性，一致性，隔离性，永久性，即ACID。  
### 原子性
  事务的原子性是指事务必须是一个原子的操作序列单元，事务中包括的各项数据操作在一次执行过程中，要么全部成功，要么全部失败。任何一项操作失败都将导致整个事务失败，同时其他已经执行的操作需要撤销并回滚，只有所有的操作全部成功，整个事务才算成功完成。  
### 一致性
  事务的一致性是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库必须处于一致性状态。也就是说事务的执行是使数据库从一个一致性状态转换到另一个一致性状态。  
### 隔离性
  事务的隔离性是指在并发环境中，并发的事务是相互隔离的，一个事务的执行不能影响其他事务的执行也不能被其他事务所影响。  
### 永久性
  事务的永久性指的是如果一个事务已经提交了，那么它对数据库中数据的变更是永久性的。
在单机数据库中，可以很容易实现一套满足ACID特性的事务处理系统，但是在分布式数据库中，数据分散在不同的机器上，这就对事务的实现提出了挑战。  
### CAP和BASE理论
  在分布式环境中，如果想要实现一套严格满足ACID特性的事务处理系统，那么系统的一致性和可用性就会有很大的冲突。基于此，出现了两个著名的分布式事务的理论，**CAP定理和BASE理论**   
**CAP定理**：该定理的内容说的是在一个分布式系统中不可能同时满足一致性（C：Consisttency）、可用性（A：Available）和分区容错性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中的两项。  
**BASE理论**：BASE是Basically Available（基本可用）、Soft state（软状态）、Eventualy consistent(最终一致性)，该理论是基于CAP定理逐步演化而来的，是对CAP中一致性和可用性权衡后的结果。其核心思想就是即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式来达到最终一致性。  
## 2PC与3PC
  前面的介绍可以了解到，一个分布式系统往往会在系统的可用性和数据一致性之间进行反复的权衡，所以产生了一系列的一致性协议。其中比较著名的就是2PC，3PC和paxos算法。  
### 2PC
  在分布式系统中，各个节点可以知道自己在事务操作过程中的失败或者成功，但是无法直接获取其他节点的失败或者成功的信息。因此当一个事务需要跨过多个节点时，为了保证事务的特性，需要引入一个“协调者”的角色来统一调度，其他参与事务的节点称为参与者。基于这个思想衍生除了2PC和3PC协议。  
#### 协议说明
  二阶段提交协议是将事务的提交过程分成了两个阶段来处理，执行流程如下：  
  **阶段一：提交事务请求**  
  1.事务询问：协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并等待参与者的响应  
  2.执行事务：参与者执行事务操作，并将Undo和Redo信息记入事务日志中  
  3.参与者向协调者反馈事务询问的响应：如果成功执行了事务操作，返回yes响应，表示事务可以实行；没有成功执行事务，返回no，表示事务不可以执行  
  **阶段二：执行事务提交**  
  在阶段二中，协调者会根据参与者的反馈情况来决定是否可以进行事务提交，正常情况下，包含以下两种可能。  
  执行事务提交：  
  假如所有参与者返回的信息都是yes，执行事务提交  
  1.发送提交请求：协调者向所有参与者节点发送commit请求  
  2.事务提交：参与者在收到commit请求之后，会正式执行事务提交操作，并在提交之后释放整个事务期间占用的资源  
  3.反馈事务提交结果：参与着在完成事务提交之后，向协调者返送Ack消息  
  4.完成事务：协调者收到所有参与者的Ack消息后，完成事务  
  中断事务：  
  假如协调者在第一阶段收到了任一一个no反馈，那么执行中断事务的操作  
  1.发送回滚请求：协调者向所有参与者发送rollback操作  
  2.事务回滚：参与者收到rollback请求之后，会利用在第一阶段记录的undo信息来进行回滚操作，并释放所占用的资源  
  3.反馈事务回滚结果： 参与者完成事务回滚之后，向协调者发送Ack信息  
  4.中断事务：协调者收到所有参与者的Ack信息之后，中断事务  
### 3pc
  由于2pc协议存在着同步阻塞，协调者的单点问题，网络分区和太过保守的容错机制等问题，所以研究者在此基础上进行了改进，提出了3pc协议。3pc，即三阶段提交协议，是将二阶段提交协议中的提交事务请求一分为二，形成了CanCommit，PreCommit和DoCommit三个阶段。  
  **阶段一：CanCommit**  
  1.事务询问：协调者向所有参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待参与者的响应。  
  2.响应反馈：参与者收到canCommit请求后，若认为自身可以执行事务，反馈yes响应，进入预备状态，否则反馈no响应。  
  **阶段二：PreCommit**  
  在阶段二中协调者会根据参与者的反馈情况来决定是执行preCommit，还是中断事务。  
  执行事务预提交  
  假如参与者反馈的都是yes响应，那么执行事务预提交。  
  1.发送预提交请求：协调者向所有参与者发送PreCommit请求，并进入准备阶段  
  2.事务预提交：参与者收到PreCommit请求后，执行事务操作，并将undo和redo的信息记录到事务日志中  
  3.响应反馈：参与者如果成功执行了事务，则响应ack信息，同时等待最后的指令，提交或者终止
  中断事务  
  假如有一个参与者在阶段一中返回的是no响应，则执行中断事务  
  1.发送中断请求：协调者向所有参与者节点发送abort请求  
  2.中断事务：参与者无论是收到了协调者发送的abort请求，还是在等待协调者请求过程中出现了超时，都会中断事务。  
  **阶段三：DoCommit**  
  该阶段是进行真正的事务提交，会存在以下两种情况  
  执行提交  
  1.发送提交请求：协调者如果此时工作正常，那么他会向所有参与者发送提交请求，并且自身从预提交转成提交状态  
  2.事务提交：参与者收到提交请求之后，提交事务，并释放相关资源  
  3.结果反馈：参与者提交事务之后，向协调者发送ack响应  
  4.完成事务：协调者收到所有参与者的ack响应之后，完成事务  
  中断事务  
  1.发送中断请求：协调者向所有参与者发送abort请求  
  2.事务回滚：参与者收到中断请求之后，会利用二阶段记录的undo信息进行事务回滚操作，回滚之后释放占用的资源  
  3.反馈事务回滚结果：参与者完成回滚之后，向参与者发送ack响应  
  4.中断事务：协调者收到所有参与者的ack响应之后，回滚事务  
